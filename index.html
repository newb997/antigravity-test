<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Hello World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050508;
            /* Deep dark background */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: crosshair;
            /* Interactive feel */
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            /* Optional subtle glow overlay */
            filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.2));
        }

        /* Instructions overlay */
        .instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            letter-spacing: 3px;
            pointer-events: none;
            text-transform: uppercase;
            animation: pulse 2.5s infinite ease-in-out;
            text-align: center;
        }

        .instruction span {
            color: #00e5ff;
            font-weight: bold;
        }

        @keyframes pulse {
            0% {
                opacity: 0.3;
            }

            50% {
                opacity: 0.9;
                text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
            }

            100% {
                opacity: 0.3;
            }
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>
    <div class="instruction">Move mouse to interact &bull; <span>Click</span> to scatter</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        let width, height;
        let particlesArray = [];
        let mouse = {
            x: null,
            y: null,
            radius: 120, // Hover radius
            clicked: false
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            initResolution();
            initParticles();
        });

        // Mouse events (Hover)
        window.addEventListener('mousemove', (event) => {
            mouse.x = event.x;
            mouse.y = event.y;
        });

        // Mouse events (Click)
        window.addEventListener('mousedown', () => {
            mouse.clicked = true;
            mouse.radius = 350; // Huge blast radius on click
            createClickRipple();
        });

        window.addEventListener('mouseup', () => {
            mouse.clicked = false;
            mouse.radius = 120; // Restore hover radius
        });

        // Remove interaction when mouse leaves window
        window.addEventListener('mouseout', () => {
            mouse.x = undefined;
            mouse.y = undefined;
        });

        // Touch support for mobile interaction
        window.addEventListener('touchstart', (event) => {
            mouse.x = event.touches[0].clientX;
            mouse.y = event.touches[0].clientY;
            mouse.clicked = true;
            mouse.radius = 250;
            createClickRipple();
        });

        window.addEventListener('touchmove', (event) => {
            mouse.x = event.touches[0].clientX;
            mouse.y = event.touches[0].clientY;
        });

        window.addEventListener('touchend', () => {
            mouse.x = undefined;
            mouse.y = undefined;
            mouse.clicked = false;
            mouse.radius = 120;
        });

        function initResolution() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // Main Text Particle Class
        class Particle {
            constructor(x, y) {
                this.originX = x;
                this.originY = y;
                // Start scattered randomly around the screen
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 2.5 + 1; // Varying particle sizes

                // Color palette assignment (Neon Pink, Purple, Cyan, White)
                const colors = ['#ff007f', '#7000ff', '#00e5ff', '#ffffff'];
                // 60% chance for cyan, 20% pink, 10% purple, 10% white
                const rand = Math.random();
                if (rand < 0.6) this.color = colors[2];
                else if (rand < 0.8) this.color = colors[0];
                else if (rand < 0.9) this.color = colors[1];
                else this.color = colors[3];

                this.baseX = x;
                this.baseY = y;
                this.density = (Math.random() * 30) + 5; // Weight of the particle against mouse
                this.friction = 0.88; // Slide friction
                this.ease = 0.05 + (Math.random() * 0.05); // Snap back speed
                this.vx = 0;
                this.vy = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update() {
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                // Force calculation (Repel from mouse)
                let forceDirectionX = dx / distance;
                let forceDirectionY = dy / distance;
                let maxDistance = mouse.radius;
                let force = (maxDistance - distance) / maxDistance;
                let directionX = forceDirectionX * force * this.density;
                let directionY = forceDirectionY * force * this.density;

                if (distance < mouse.radius) {
                    // Explode stronger when clicked
                    let multiplier = mouse.clicked ? 5 : 1;
                    this.vx -= directionX * multiplier;
                    this.vy -= directionY * multiplier;
                } else {
                    // Return to original base position to form text
                    let dxBase = this.baseX - this.x;
                    let dyBase = this.baseY - this.y;
                    this.vx += dxBase * this.ease;
                    this.vy += dyBase * this.ease;
                }

                // Apply velocity and friction
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;

                // Idle slow floating effect when settled
                if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1 && distance >= mouse.radius) {
                    this.x += Math.sin(Date.now() * 0.001 + this.originX) * 0.2;
                    this.y += Math.cos(Date.now() * 0.001 + this.originY) * 0.2;
                }
            }
        }

        // Interactive Background Particle Class
        class BGParticle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = Math.random() * 2;
                this.speedX = Math.random() * 0.5 - 0.25;
                this.speedY = Math.random() * 0.5 - 0.25;
                this.color = `rgba(255, 255, 255, ${Math.random() * 0.2})`;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;

                // Wrap around screen
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        let bgParticles = [];

        function initParticles() {
            particlesArray = [];

            // 1. Draw text off-screen to read pixels
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Responsive font size
            let fontSize = Math.min(width * 0.15, 180);
            if (width < 600) fontSize = width * 0.2; // Larger on small screens relative to width

            ctx.font = `900 ${fontSize}px 'Outfit', 'Segoe UI', sans-serif`;

            // Draw text in the middle
            const text1 = "HELLO";
            const text2 = "WORLD";

            // Multi-line for smaller screens
            if (width < 800) {
                ctx.fillText(text1, width / 2, height / 2 - fontSize * 0.6);
                ctx.fillText(text2, width / 2, height / 2 + fontSize * 0.4);
            } else {
                ctx.fillText(text1 + " " + text2, width / 2, height / 2);
            }

            // 2. Scan screen pixels where alpha > 0 (text is drawn)
            const textCoordinates = ctx.getImageData(0, 0, width, height);

            // Clear canvas after getting data so we can draw particles instead
            ctx.clearRect(0, 0, width, height);

            // 3. Create particles based on pixel density
            let step = Math.floor(width / 350); // Particle gap (density)
            if (step < 3) step = 3;
            if (width < 600) step = 2; // denser on mobile

            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    // Get alpha property for specific pixel
                    const index = (y * width + x) * 4;
                    const alpha = textCoordinates.data[index + 3];

                    if (alpha > 128) {
                        particlesArray.push(new Particle(x, y));
                    }
                }
            }

            // 4. Initialize scattered background constellation effect
            bgParticles = [];
            let numBG = Math.floor((width * height) / 8000);
            for (let i = 0; i < numBG; i++) {
                bgParticles.push(new BGParticle());
            }
        }

        let ripples = [];

        // Special effect: Shockwave ripple on click
        function createClickRipple() {
            ripples.push({
                x: mouse.x || width / 2,
                y: mouse.y || height / 2,
                radius: 10,
                alpha: 1,
                color: mouse.clicked ? '#ff007f' : '#00e5ff'
            });
        }

        function drawRipples() {
            for (let i = 0; i < ripples.length; i++) {
                let r = ripples[i];
                ctx.beginPath();
                ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 229, 255, ${r.alpha})`; // Cyan ripple
                ctx.lineWidth = 3;
                ctx.stroke();

                // Explode outwards
                r.radius += 20;
                r.alpha -= 0.04; // Fade out

                // Remove when invisible
                if (r.alpha <= 0) {
                    ripples.splice(i, 1);
                    i--;
                }
            }
        }

        // Draw connections between background particles (Constellation effect)
        function connectBGLines() {
            for (let a = 0; a < bgParticles.length; a++) {
                for (let b = a; b < bgParticles.length; b++) {
                    let dx = bgParticles[a].x - bgParticles[b].x;
                    let dy = bgParticles[a].y - bgParticles[b].y;
                    let distance = dx * dx + dy * dy;

                    if (distance < 12000) {
                        let opacity = 1 - (distance / 12000);
                        ctx.strokeStyle = `rgba(100, 150, 255, ${opacity * 0.15})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(bgParticles[a].x, bgParticles[a].y);
                        ctx.lineTo(bgParticles[b].x, bgParticles[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Main Animation Loop
        function animate() {
            // Trail effect: clear with slight opacity to leave motion blur
            ctx.fillStyle = 'rgba(5, 5, 8, 0.25)';
            ctx.fillRect(0, 0, width, height);

            // Update & Draw Background Particles & Lines
            for (let i = 0; i < bgParticles.length; i++) {
                bgParticles[i].update();
                bgParticles[i].draw();
            }
            connectBGLines();

            // Update & Draw Main Text Particles
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
                particlesArray[i].draw();
            }

            // Draw Click Ripples
            drawRipples();

            requestAnimationFrame(animate);
        }

        // Initialization
        initResolution();

        // Ensure fonts are loaded before calculating text placement
        // Fallback for browsers without document.fonts
        if (document.fonts) {
            document.fonts.ready.then(() => {
                initParticles();
                animate();
                introAnimation();
            });
        } else {
            setTimeout(() => {
                initParticles();
                animate();
                introAnimation();
            }, 500);
        }

        // Dramatic Intro: Particles fly in to form text, then simulate a blast
        function introAnimation() {
            setTimeout(() => {
                mouse.x = width / 2;
                mouse.y = height / 2;
                mouse.clicked = true;
                mouse.radius = Math.max(width, height); // Huge radius
                createClickRipple();

                // Release force after short time
                setTimeout(() => {
                    mouse.x = undefined;
                    mouse.y = undefined;
                    mouse.clicked = false;
                    mouse.radius = 120;
                }, 150);
            }, 800);
        }

    </script>
</body>

</html>